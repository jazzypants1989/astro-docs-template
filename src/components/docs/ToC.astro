---
import { getCollection } from "astro:content"

const docs = await getCollection("docs")

const docFolders = docs.map((doc) => {
  if (doc.id.split("/").length > 1) {
    return doc.id.split("/")[0]
  }
})

// Iterate through the documents and determine the folders based on the amount of slashes in each id.
// More than one slash means that the first part of the path is a folder name.
// So, we return the first part of each path that has multiples slashes to get all of our folder names to use as categories.
// This will only work one level deep, but that's fine for now.

const uniqueFolders = [...new Set(docFolders)]

// Remove any duplicates from the array.

const transformedFolders = uniqueFolders.map((folder) =>
  transformSnakeCase(folder)
)

// Transform the folder names to be more readable (e.g. "getting-started" => "Getting Started")

function transformSnakeCase(str: string | undefined) {
  if (!str)
    return {
      original: "",
      transformed: "",
    }
  return {
    original: str,
    transformed: str
      .split("-")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(" "),
  }
}

// Create an object with the original folder name and the transformed folder name.
// We kept the original so we can compare it to the links in the sidebar (to determine if one of it's children is active.)

const coreDocs = docs.filter(
  (doc) =>
    doc.id.split("/")[0].includes(".md") ||
    doc.id.split("/")[0].includes(".mdx")
)

// Filter out the core docs from the sidebar.
// Basically, if it's in the root folder and it's a markdown file (not a folder), it must be a core doc.

const currentPage = Astro.url.pathname

// Get the current page so we can determine if it's active in the sidebar.

function removeTrailingSlash(path: string) {
  return path.replace(/\/$/, "")
}

function inPathWithoutHome(path: string, href: string) {
  return removeTrailingSlash(path).startsWith(href) && href !== "/"
}

const isActive = (href: string) => {
  return inPathWithoutHome(currentPage, href) ? "active" : ""
}
---

<form class="w-full flex flex-col items-center justify-center">
  <input
    id="search"
    type="text"
    placeholder="Search"
    class="w-8/12 text-black rounded-md border border-primary-DARKER"
  />
</form>

<ul
  class="bg-primary-MEDIUM text-primary-LIGHT m-2 rounded-lg w-full"
  id="search-results"
>
</ul>

<h3 class="text-3xl font-bold">Table of Contents</h3>
<ul>
  <li>
    <a
      class={(isActive("/docs") && currentPage === "/docs") ||
      (isActive("/docs") && currentPage === "/docs/")
        ? "active"
        : ""}
      href="/docs">Introduction</a
    >
  </li>
  {
    coreDocs.map((doc) => (
      <li>
        <a
          class={isActive(`/docs/${doc.slug}`) ? "active" : ""}
          href={`/docs/${doc.slug}`}
        >
          {doc.data.title}
        </a>
      </li>
    ))
  }
</ul>
{
  transformedFolders.map(({ original, transformed }) => (
    <div>
      <h4 class="text-2xl font-bold">{transformed}</h4>
      <ul>
        {docs.map((doc) => {
          if (doc.id.split("/")[0] === original) {
            return (
              <li>
                <a
                  class={isActive(`/docs/${doc.slug}`)}
                  href={`/docs/${doc.slug}`}
                >
                  {doc.data.title}
                </a>
              </li>
            )
          }
        })}
      </ul>
    </div>
  ))
}

<script>
  const input = document.getElementById("search") as HTMLInputElement
  const resultsArea = document.getElementById(
    "search-results"
  ) as HTMLUListElement
  const urlParams = new URLSearchParams(
    window.location.search
  ) as URLSearchParams

  if (urlParams.has("search")) {
    const searchParam = urlParams.get("search")
    if (searchParam) {
      input.value = searchParam
      search(searchParam)
    }
  }

  async function search(query: string) {
    const res = await fetch("/search")
    const data = await res.json()

    const results = data.filter((doc: { title: string; text: string }) => {
      return (
        doc.title.toLowerCase().includes(query.toLowerCase()) ||
        doc.text.toLowerCase().includes(query.toLowerCase())
      )
    })

    function contextFinder(text: string, query: string) {
      const index = text.toLowerCase().indexOf(query.toLowerCase())
      const start = index - 10
      const end = index + 30
      const context = text.slice(start, end)
      return context
    }

    resultsArea.innerHTML = ""

    if (results.length > 0) {
      let id = 0
      results.forEach(
        (result: { title: string; text: string; url: string }) => {
          id++
          const context = contextFinder(result.text, query)
          resultsArea.innerHTML += `
          <li
            class="border-b border-primary-DARKER"
          >
            <a 
            class="block p-4 text-white"
            id="result-${id}"
            href="${result.url}">
              <h3
              class="text-xl font-bold"
              >${result.title}</h3>
              <p
              class="text-sm font-light truncate"
              >${context}</p>
            </a>
          </li>
        `
        }
      )
    } else {
      resultsArea.innerHTML = `
        <li>
          <p>No results found.</p>
        </li>
      `
    }

    if (query === "") {
      resultsArea.innerHTML = ""
    }

    console.log(results)

    return results
  }

  function throttleAndDebounce(fn: Function, delay: number) {
    let timerId: any

    return function (...args: any[]) {
      if (timerId) {
        console.log("throttled")
        resultsArea!.innerHTML = `
          <li>
            <p>Searching...</p>
          </li>
        `
        console.log(timerId)
        clearTimeout(timerId)
      }

      timerId = setTimeout(() => {
        console.log("debounced")
        fn(...args)
        timerId = null
      }, delay)
    }
  }

  const throttledSearch = throttleAndDebounce(search, 500)

  function handleInput(e: Event) {
    const query = (e.target as HTMLInputElement).value
    if (query.length < 3) {
      resultsArea.innerHTML = ""
    }
    if (query.length > 2) {
      throttledSearch(query)
    }
  }

  setInterval(() => {
    console.log("I'm checking again, boss! ðŸ¤–")
    if (input.value.length < 3) {
      resultsArea.innerHTML = ""
    }
  }, 1000)

  input.addEventListener("input", handleInput)
</script>
